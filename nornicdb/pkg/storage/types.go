// Package storage provides the storage engine interface and implementations for NornicDB.
// This package follows testability-first design with dependency injection.
package storage

import (
	"encoding/json"
	"errors"
	"time"
)

// Common errors
var (
	ErrNotFound       = errors.New("not found")
	ErrAlreadyExists  = errors.New("already exists")
	ErrInvalidID      = errors.New("invalid id")
	ErrInvalidData    = errors.New("invalid data")
	ErrStorageClosed  = errors.New("storage closed")
)

// NodeID is a strongly-typed node identifier.
type NodeID string

// EdgeID is a strongly-typed edge identifier.
type EdgeID string

// Node represents a graph node in Neo4j-compatible format.
// This matches Neo4j's internal node structure for import/export compatibility.
type Node struct {
	ID         NodeID            `json:"id"`
	Labels     []string          `json:"labels"`
	Properties map[string]any    `json:"properties"`
	
	// NornicDB extensions (stored in properties for Neo4j compat)
	CreatedAt    time.Time `json:"-"`
	UpdatedAt    time.Time `json:"-"`
	DecayScore   float64   `json:"-"`
	LastAccessed time.Time `json:"-"`
	AccessCount  int64     `json:"-"`
	Embedding    []float32 `json:"-"`
}

// Edge represents a graph relationship in Neo4j-compatible format.
type Edge struct {
	ID         EdgeID            `json:"id"`
	StartNode  NodeID            `json:"startNode"`
	EndNode    NodeID            `json:"endNode"`
	Type       string            `json:"type"`
	Properties map[string]any    `json:"properties"`
	
	// NornicDB extensions
	CreatedAt     time.Time `json:"-"`
	Confidence    float64   `json:"-"`
	AutoGenerated bool      `json:"-"`
}

// Engine defines the storage engine interface.
// All implementations must be safe for concurrent use.
type Engine interface {
	// Node operations
	CreateNode(node *Node) error
	GetNode(id NodeID) (*Node, error)
	UpdateNode(node *Node) error
	DeleteNode(id NodeID) error
	
	// Edge operations  
	CreateEdge(edge *Edge) error
	GetEdge(id EdgeID) (*Edge, error)
	UpdateEdge(edge *Edge) error
	DeleteEdge(id EdgeID) error
	
	// Query operations
	GetNodesByLabel(label string) ([]*Node, error)
	GetOutgoingEdges(nodeID NodeID) ([]*Edge, error)
	GetIncomingEdges(nodeID NodeID) ([]*Edge, error)
	GetEdgesBetween(startID, endID NodeID) ([]*Edge, error)
	
	// Bulk operations (for import)
	BulkCreateNodes(nodes []*Node) error
	BulkCreateEdges(edges []*Edge) error
	
	// Lifecycle
	Close() error
	
	// Stats
	NodeCount() (int64, error)
	EdgeCount() (int64, error)
}

// Neo4jExport represents the Neo4j JSON export format.
// This is compatible with `neo4j-admin database dump` JSON output.
type Neo4jExport struct {
	Nodes         []Neo4jNode         `json:"nodes"`
	Relationships []Neo4jRelationship `json:"relationships"`
}

// Neo4jNode is the Neo4j JSON export format for nodes.
type Neo4jNode struct {
	ID         string            `json:"id"`
	Labels     []string          `json:"labels"`
	Properties map[string]any    `json:"properties"`
}

// Neo4jNodeRef is a reference to a node in Neo4j relationship format.
type Neo4jNodeRef struct {
	ID     string   `json:"id"`
	Labels []string `json:"labels,omitempty"`
}

// Neo4jRelationship is the Neo4j JSON export format for relationships.
// Supports both flat format (startNode/endNode strings) and APOC format (start/end objects).
type Neo4jRelationship struct {
	ID         string            `json:"id"`
	Type       string            `json:"type"`
	Properties map[string]any    `json:"properties"`
	
	// Flat format (neo4j-admin dump)
	StartNode  string            `json:"startNode,omitempty"`
	EndNode    string            `json:"endNode,omitempty"`
	
	// APOC format (apoc.export.json)
	Start      Neo4jNodeRef      `json:"start,omitempty"`
	End        Neo4jNodeRef      `json:"end,omitempty"`
}

// GetStartID returns the start node ID regardless of format.
func (r *Neo4jRelationship) GetStartID() string {
	if r.Start.ID != "" {
		return r.Start.ID
	}
	return r.StartNode
}

// GetEndID returns the end node ID regardless of format.
func (r *Neo4jRelationship) GetEndID() string {
	if r.End.ID != "" {
		return r.End.ID
	}
	return r.EndNode
}

// ToNeo4jExport converts internal nodes and edges to Neo4j export format.
func ToNeo4jExport(nodes []*Node, edges []*Edge) *Neo4jExport {
	export := &Neo4jExport{
		Nodes:         make([]Neo4jNode, len(nodes)),
		Relationships: make([]Neo4jRelationship, len(edges)),
	}
	
	for i, n := range nodes {
		export.Nodes[i] = Neo4jNode{
			ID:         string(n.ID),
			Labels:     n.Labels,
			Properties: n.mergeInternalProperties(),
		}
	}
	
	for i, e := range edges {
		props := make(map[string]any)
		for k, v := range e.Properties {
			props[k] = v
		}
		// Add edge-specific internal properties
		if e.Confidence > 0 {
			props["_confidence"] = e.Confidence
		}
		if e.AutoGenerated {
			props["_autoGenerated"] = e.AutoGenerated
		}
		if !e.CreatedAt.IsZero() {
			props["_createdAt"] = e.CreatedAt.Unix()
		}
		
		export.Relationships[i] = Neo4jRelationship{
			ID:         string(e.ID),
			StartNode:  string(e.StartNode),
			EndNode:    string(e.EndNode),
			Type:       e.Type,
			Properties: props,
		}
	}
	
	return export
}

// FromNeo4jExport converts Neo4j export format to internal nodes and edges.
func FromNeo4jExport(export *Neo4jExport) ([]*Node, []*Edge) {
	nodes := make([]*Node, len(export.Nodes))
	edges := make([]*Edge, len(export.Relationships))
	
	for i, n := range export.Nodes {
		// Copy properties
		props := make(map[string]any)
		for k, v := range n.Properties {
			props[k] = v
		}
		
		node := &Node{
			ID:         NodeID(n.ID),
			Labels:     n.Labels,
			Properties: props,
			DecayScore: 1.0, // Default
		}
		// Extract internal properties from the properties map
		node.ExtractInternalProperties()
		nodes[i] = node
	}
	
	for i, r := range export.Relationships {
		// Copy properties
		props := make(map[string]any)
		for k, v := range r.Properties {
			props[k] = v
		}
		
		edge := &Edge{
			ID:         EdgeID(r.ID),
			StartNode:  NodeID(r.GetStartID()),
			EndNode:    NodeID(r.GetEndID()),
			Type:       r.Type,
			Properties: props,
		}
		
		// Extract edge-specific internal properties
		if conf, ok := props["_confidence"].(float64); ok {
			edge.Confidence = conf
			delete(edge.Properties, "_confidence")
		}
		if auto, ok := props["_autoGenerated"].(bool); ok {
			edge.AutoGenerated = auto
			delete(edge.Properties, "_autoGenerated")
		}
		if created, ok := props["_createdAt"].(float64); ok {
			edge.CreatedAt = time.Unix(int64(created), 0)
			delete(edge.Properties, "_createdAt")
		}
		
		edges[i] = edge
	}
	
	return nodes, edges
}

// MarshalNeo4jJSON serializes to Neo4j-compatible JSON.
func (n *Node) MarshalNeo4jJSON() ([]byte, error) {
	neo4j := Neo4jNode{
		ID:         string(n.ID),
		Labels:     n.Labels,
		Properties: n.mergeInternalProperties(),
	}
	return json.Marshal(neo4j)
}

// mergeInternalProperties adds NornicDB-specific fields to properties.
func (n *Node) mergeInternalProperties() map[string]any {
	props := make(map[string]any)
	for k, v := range n.Properties {
		props[k] = v
	}
	
	// Add internal properties with _ prefix (Neo4j convention for system props)
	props["_createdAt"] = n.CreatedAt.Unix()
	props["_updatedAt"] = n.UpdatedAt.Unix()
	props["_decayScore"] = n.DecayScore
	props["_lastAccessed"] = n.LastAccessed.Unix()
	props["_accessCount"] = n.AccessCount
	
	return props
}

// ExtractInternalProperties extracts NornicDB-specific fields from properties.
func (n *Node) ExtractInternalProperties() {
	if n.Properties == nil {
		return
	}
	
	if v, ok := n.Properties["_createdAt"].(float64); ok {
		n.CreatedAt = time.Unix(int64(v), 0)
		delete(n.Properties, "_createdAt")
	}
	if v, ok := n.Properties["_updatedAt"].(float64); ok {
		n.UpdatedAt = time.Unix(int64(v), 0)
		delete(n.Properties, "_updatedAt")
	}
	if v, ok := n.Properties["_decayScore"].(float64); ok {
		n.DecayScore = v
		delete(n.Properties, "_decayScore")
	}
	if v, ok := n.Properties["_lastAccessed"].(float64); ok {
		n.LastAccessed = time.Unix(int64(v), 0)
		delete(n.Properties, "_lastAccessed")
	}
	if v, ok := n.Properties["_accessCount"].(float64); ok {
		n.AccessCount = int64(v)
		delete(n.Properties, "_accessCount")
	}
}
